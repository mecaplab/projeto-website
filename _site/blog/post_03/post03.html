<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lucas S. Santos">
<meta name="dcterms.date" content="2024-04-04">

<title>MECAP.LAB - Parte II - Dados textuais e previsão de variáveis financeiras</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/new-logo-mecaplab.svg" rel="icon" type="image/svg+xml">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="MECAP.LAB - Parte II - Dados textuais e previsão de variáveis financeiras">
<meta property="og:description" content="Site do MECAP.LAB">
<meta property="og:image" content="https://mecaplab.netlify.app/blog/post_03/thumb_02.png">
<meta property="og:site_name" content="Quarto">
<meta property="og:locale" content="pt_BR">
<meta property="og:image:height" content="552">
<meta property="og:image:width" content="890">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">MECAP.LAB</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Ínicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Sobre</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mecaplab"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.instagram.com/mecaplab"> <i class="bi bi-instagram" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Parte II - Dados textuais e previsão de variáveis financeiras</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">data_science</div>
                <div class="quarto-category">mercado_de_capitais</div>
                <div class="quarto-category">nlp</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Lucas S. Santos </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 4, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#resultados-e-discussão" id="toc-resultados-e-discussão" class="nav-link active" data-scroll-target="#resultados-e-discussão">RESULTADOS E DISCUSSÃO</a></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão">CONCLUSÃO</a></li>
  <li><a href="#referências" id="toc-referências" class="nav-link" data-scroll-target="#referências">REFERÊNCIAS</a></li>
  <li><a href="#apêndices" id="toc-apêndices" class="nav-link" data-scroll-target="#apêndices">APÊNDICES</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Continuação da <a href="../post_02/post02.html">Parte I - Dados textuais e previsão de variáveis financeiras.</a></p>
<section id="resultados-e-discussão" class="level1">
<h1>RESULTADOS E DISCUSSÃO</h1>
<p>Partindo para a análise por clusters K-means, carregamos nosso corpus pré-processado anteriormente e salvo como arquivo csv. Contamos inicialmente com duas variáveis, que são a variável “Nome” que é o nome identificador de cada empresa e a variável “Texto”&nbsp; que nada mais é que a descrição das atividades das empresas, como visto abaixo.</p>
<p><strong>Figura 04:</strong> Corpus. <br> <img src="figura_04.png" width="500"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>
<p>Depois criamos uma segunda tabela, desta vez com quatro variáveis conforme a “Figura 05: Corpus Pré-processado”, agora com as variáveis “Tokens_Preprocessados” e “Texto_Preprocessado”, essas variáveis são importantes para as próximas etapas e para que não seja necessário pré-processar os arquivos novamente, tarefa esta que demandou cerca de 30 minutos.</p>
<p><strong>Figura 05:</strong> Corpus Pré-processado. <br> <img src="figura_05.png" width="100%"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>
<p>Para uma compreensão geral no início da análise foi construído “Nuvens de Palavras” para que fosse possível visualizar as palavras mais frequentes em uma amostra dos nossos documentos. Após ter utilizado as nuvens de palavras para também ajudar a construir nosso arquivo de “StopWords” removendo assim estas palavras da nossa análise. Com o “TfidfVectorizer” da biblioteca sklearn, vetorizamos nosso corpus, como pode ser visto na “Figura 06: Vetor TF-IDF” uma parte dos vetores.</p>
<p><strong>Figura 06:</strong> Vetor TF-IDF. <br> <img src="figura_06.png" width="300"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>
<p>Em seguida, analisamos através do “Gráfico 01: Top 50 tokens” os cinquenta tokens/palavras mais frequentes em nosso corpus, onde houve uma anomalia que consistiu em que os tokens “de” e “em”&nbsp; que foram postos anteriormente em nossa lista de StopWords, porém estes tokens ainda foram contados na análise, o que pode ter sido uma falha em nosso código. Essa distribuição de frequência nos fornece a frequência de cada item do vocabulário no texto. Como podemos ver considerando as palavras mais representativas para caracterizar a atividade de um setor de empresa em ambiente de bolsa as palavras mais frequentes não chegam a uma frequência de 50x e entre aquelas mais representativas e frequentes estão tokens como “energia”, “serviço”, “produto”, “elétrico”, “crédito”, “financeiro”, “imobiliário”, “distribuição” e “mercantil”.</p>
<p><strong>Gráfico 01:</strong> Top 50 tokens. <br> <img src="gráfico_01.png" width="600"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>
<p>Como citado anteriormente o algoritmo K-means necessita que passemos para ele um número k de clusters, essa escolha é difícil principalmente porque estamos trabalhando com análise não-supervisionada, ou seja nossos dados não estão rotulados, e queremos testar justamente quantos clusters o algoritmo irá entender como ideal e quais empresas o K-means agrupa-rá juntamente como diferentes setores de atuação. Uma das maneiras de fazer isso, mas com algumas limitações, é o “Elbow Method” ou “Método Cotovelo” em tradução livre. Bengfort e Bilbro (2019) apresentaram uma visualização do método “cotovelo” para ajudar os cientistas de dados a selecionar o número ideal de clusters, ajustando o modelo com uma faixa de valores. Se o gráfico de linhas se assemelha a um braço, então o “cotovelo” (o ponto de inflexão na curva) é uma boa indicação de que o modelo subjacente se encaixa melhor nesse ponto.</p>
<p>Sabemos que o número de clusters, que neste trabalho representam setores econômicos em que as empresas estão alocadas, conforme a B3 (2023) é de doze (12) setores econômicos, quarenta e cinco (45) subsetores econômicos e oitenta segmentos de atuação. Já o número de setores econômicos segundo a NAICS é de cento e quatro (104). Logo nosso número de grupos deve se assemelhar a estes números da B3 e também podendo ser comparado aos setores da NAICS. Pelo método cotovelo, temos um número ideal k de grupos igual a seis (6).</p>
<p><strong>Gráfico 02:</strong> Método cotovelo para clusterização K-means. <br> <img src="gráfico_02.png" width="600"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>
<p>Utilizando outro método que é o Silhouette, também chamado de Coeficiente de Silhueta. O Coeficiente de Silhueta é usado quando a verdade fundamental sobre o conjunto de dados é desconhecida e calcula a densidade de clusters computados pelo modelo. O escore é calculado pela média do coeficiente de silhueta de cada amostra, calculado como a diferença entre a distância intra conglomerado média e a distância média mais próxima de cada amostra, normalizada pelo valor máximo. Isso produz uma pontuação entre 1 e -1, onde 1 é agrupamento altamente denso e -1 é agrupamento completamente incorreto (BENGFORT; BILBRO, 2019).</p>
<p>Nossos critérios para selecionar a melhor visualização de cluster são os seguintes, conforme este método:</p>
<ul>
<li>Presença de mais aglomerados com pontuações de silhueta acima da média (conforme indicado pela linha tracejada).</li>
<li>Menos flutuação no tamanho dos gráficos de silhueta (indicando aglomerados mais uniformes).</li>
<li>Menos pontos negativos, que representam possíveis agrupamentos incorretos.</li>
</ul>
<p>Assim, usando a função <code>SilhouetteVisualizer</code> da biblioteca python <code>Yellowbrick</code>, vemos que diante dos critérios um bom número de clusters é vinte e sete (27). Comparando entre os dois métodos um bom k estaria entre 5 e 27, como vimos que nos critérios de classificação da B3&nbsp; o número é bem maior que cinco, utilizamos então o <code>k=27</code> conforme o coeficiente de silhueta, veja o Apêndice A – Coeficiente de Silhueta “Gráfico 03: Coeficiente de Silhueta” e verificamos na dispersão dos dados como o agrupamento se comportou.</p>
<p>Com o nosso k selecionado, podemos então rodar o algoritmo K-means, mas antes uma técnica comumente aplicada juntamente com o K-means é a decomposição PCA para a redução de dimensionalidade dos nossos vetores, aplicamos então o PCA aos nossos vetores, esta é uma etapa muito importante para nosso resultado. Após rodar o K-means podemos visualizar o resultado conforme o “Gráfico 04: Dispersão dos clusters”.</p>
<p><strong>Gráfico 04:</strong> Dispersão dos clusters. <br> <img src="gráfico_04.png" width="600"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>
<p>Como observado na dispersão dos 27 clusters, há grupos bem condensados e grupos dispersos, os símbolos de “x” representam o centro de cada grupo. Com a análise tem-se no canto superior direito do “Gráfico 04” pontos que representam empresas sobrepostas as quais algumas delas são: Schulz e Tupy que são empresas do setor de autopeças, Telinvest e Zain que são do setor de telecomunicações, além de empresas como a Longdis do setor de administração entre outras empresas além das mencionadas. Tomando este grupo como exemplo, podemos supor que o método de clusterização por K-means nas várias descrições de atividades não se aplica bem, mas vale ressaltar que as descrições também podem não conter com descrições relevantes, ou seja palavras que fazem referência direta às atividades da empresa e que não são tão frequentes em todos os documentos de empresas do mesmo setor conforme a B3 ou NAICS, como vimos no método TF-IDF.</p>
<p>Entretanto empresas do setor elétrico apresentam formulários de referência (FRE) com uma maior quantidade de texto descritivo e com palavras bem mais relevantes em termos de representação do setor, isso mostra que a CVM órgão que normatiza a estrutura da FRE, regula a sua entrega e recebe os formulários juntamente com a B3 podem tomar alguma medida de mudança quanto às normas e critérios de elaboração das FREs para que assim todas as empresas declarem sistematicamente sua atividades ano-ano, atualizando as informações aos investidores. Os pontos no canto superior esquerdo do gráfico mostram o agrupamento dessas empresas do setor elétrico, que conforme a NAICS podem ser empresas: “empresa de eletricidade, gás e água” ou “geração, transmissão e distribuição de energia elétrica”.</p>
<p>Como o objetivo é agrupar as empresas semelhantes em grupos o mais distintos possíveis, é importante entender a similaridade entre os clusters para isso usamos a matriz de similaridade ou mapa de calor com valores entre 1 (maior similaridade) e -1 (menor similaridade) visualizados pelos tons mais escuros e mais claros.</p>
<p>No “Gráfico 05: Matriz de similaridade” podemos notar que os clusters estão bem agrupados da perspectiva da similaridade entre os grupos, já que os valores da matriz variam bastante com relação a 1. Veja o Apêndice A – Coeficiente de Silhueta.</p>
</section>
<section id="conclusão" class="level1">
<h1>CONCLUSÃO</h1>
<p>Neste estudo, exploramos a aplicação de técnicas de Processamento de Linguagem Natural (PLN) e Aprendizado de Máquina (ML) na análise de dados não estruturados contidos em relatórios financeiros anuais de empresas brasileiras. Utilizando o algoritmo K-means, buscamos identificar clusters de empresas com atividades semelhantes a partir das descrições de suas atividades contidas nos Formulários de Referência (FRE) entregues à Comissão de Valores Mobiliários (CVM).</p>
<p>Os resultados obtidos revelam insights interessantes sobre a similaridade das atividades das empresas em diferentes setores. Através da análise de clusters, observamos que algumas empresas do setor elétrico apresentam agrupamentos mais definidos, indicando uma maior concentração de palavras relevantes para esse setor nos seus relatórios. Por outro lado, em alguns casos, a técnica de clusterização não apresentou agrupamentos tão distintos, possivelmente devido à falta de informações descritivas específicas nas atividades declaradas pelas empresas, indicando a necessidade de aprimoramento na consistência das descrições de atividades.</p>
<p>A contribuição deste estudo reside na demonstração da viabilidade do uso de dados não estruturados para identificar padrões e agrupamentos nas atividades empresariais. Além disso, destacamos a importância da qualidade e relevância das informações contidas nos relatórios financeiros, que podem impactar diretamente a eficácia das técnicas de análise. As empresas que fornecem descrições mais detalhadas e específicas sobre suas atividades tendem a se agrupar de maneira mais coesa. E isso pode ter implicações significativas para o mercado financeiro. Consequentemente observou-se que a maioria das empresas mesmo em igual setor usam poucas e diferentes palavras para autodescrição de suas atividades.</p>
<p>Sugestões para estudos futuros incluem a expansão desta abordagem para análises de dados de anos subsequentes, a comparação entre diferentes algoritmos de agrupamento, que possam agrupar de forma melhor que o K-means, bem como a exploração de outras fontes de dados. Além disso, uma análise mais aprofundada das limitações e desafios da análise de dados não estruturados em finanças pode fornecer insights valiosos para futuras pesquisas.</p>
</section>
<section id="referências" class="level1">
<h1>REFERÊNCIAS</h1>
<p>B3. Critério de classificação. Disponível em: https://www.b3.com.br/pt_br/produtos-e-servicos/negociacao/renda-variavel/acoes/consultas.htm. Acesso em: 04 jun. 2023.</p>
<p>BENGFORT, B; BILBRO, R. Yellowbrick: visualizing the scikit-learn model selection process. Journal Of Open Source Software, [S.l.], v. 4, n.&nbsp;35, p.&nbsp;1075, 24 mar. 2019. The Open Journal. http://dx.doi.org/10.21105/joss.01075.</p>
<p>BUITINCK, L; et al.&nbsp;Scikit-learn: machine learning in python. Journal Of Machine Learning Research. [S. L.], p.&nbsp;2825-2830. out. 2011.</p>
<p>CAI, F; LE-KHAC, N; KECHADI, M. Clustering Approaches for Financial Data Analysis: a Survey. 2016. School of Computer Science &amp; Informatics, University College Dublin, Ireland, 2016.</p>
<p>GODEIRO, L. L. Ensaios sobre Modelos de Previsão Econômica. 2018. 116 f.&nbsp;Tese (Doutorado) - Curso de Economia, Universidade Federal da Paraíba, João Pessoa, 2018.</p>
<p>HOBERG, Gerard; PHILLIPS, Gordon. Text-Based Network Industries and Endogenous Product Differentiation. Journal Of Political Economy, [S.L.], v. 124, n.&nbsp;5, p.&nbsp;1423-1465, out. 2016. University of Chicago Press. http://dx.doi.org/10.1086/688176.</p>
<p>LOUGHRAN, Tim; MCDONALD, Bill. When Is a Liability Not a Liability? Textual Analysis, Dictionaries, and 10-Ks. The Journal Of Finance, [S.L.], v. 66, n.&nbsp;1, p.&nbsp;35-65, 6 jan. 2011. Wiley. http://dx.doi.org/10.1111/j.1540-6261.2010.01625.x.</p>
<p>LOUGHRAN, T.; MCDONALD, B. Textual Analysis in Accounting and Finance: A Survey. Behavioral &amp; Experimental Finance eJournal, 2016.</p>
<p>MOLNAR, C. Interpretable Machine Learning: a guide for making black box models explainable. 2. ed.&nbsp;[S. l.]: Lulu.com, 2022. Disponível em: https://christophm.github.io/interpretable-ml-book. Acesso em: 03 jun. 2023.</p>
<p>MORISSETTE, L; CHARTIER, S. The k-means clustering technique: general considerations and implementation in mathematica. Tutorials In Quantitative Methods For Psychology, [S.L.], v. 9, n.&nbsp;1, p.&nbsp;15-24, 1 fev. 2013. The Quantitative Methods for Psychology. http://dx.doi.org/10.20982/tqmp.09.1.p015.</p>
<p>NATIONAL INSTITUTE OF STANDARDS AND TECHNOLOGY (NIST). What are outliers in the data? Disponível em: https://www.itl.nist.gov/div898/handbook/prc/section1/prc16.htm. Acesso em: 15 ago. 2023.</p>
<p>PREMEBIDA, S. M. Guia de NLP - conceitos e técnicas. 2021. Disponível em: https://www.alura.com.br/artigos/guia-nlp-conceitos-tecnicas. Acesso em: 15 ago. 2023.</p>
<p>QAISER, S; ALI, R. Text Mining: use of tf-idf to examine the relevance of words to documents. International Journal Of Computer Applications. [S. L.], p.&nbsp;25-29. ago. 2018. Disponível em: https://www.ijcaonline.org/archives/volume181/number1/qaiser-2018-ijca-917395.pdf. Acesso em: 16 maio. 2023.</p>
<p>SINGER-VINE, Jeremy; CONTRIBUTORS, The Pdfplumber. Pdfplumber. 2023. Software. Disponível em: https://github.com/jsvine/pdfplumber. Acesso em: 15 ago. 2023.</p>
<p>SPACY. Industrial-Strength Natural Language Processing: in python. in python. Disponível em: https://spacy.io/. Acesso em: 15 ago. 2023.</p>
<p>TETLOCK, P. C.; SAAR-TSECHANSKY, M.; MACSKASSY, S. A. More than Words: Quantifying Language to Measure Firms’ Fundamentals. Texas Finance Festival, 2007.</p>
<p>UNITED STATES. CENSUS BUREAU. NAICS Update Process Fact Sheet. Disponível em: https://www.census.gov/naics/reference_files_tools/NAICS_Update_Process_Fact_Sheet.pdf. Acesso em: 04 jun. 2023.**</p>
<p><br></p>
<hr>
<p><br></p>
</section>
<section id="apêndices" class="level1">
<h1>APÊNDICES</h1>
<p><strong>Gráfico 03:</strong> Coeficiente de Silhueta. <br> <img src="gráfico_03_1.png" width="100%"> <img src="gráfico_03_2.png" width="100%"> <img src="gráfico_03_3.png" width="100%"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>
<p><strong>Gráfico 05:</strong> Matriz de similaridade. <br> <img src="gráfico_05.png" width="100%"> <br> <strong>Fonte:</strong> Elaboração própria (2023).</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2024, MECAP.LAB. &lt; / &gt;</p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mecaplab">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.instagram.com/mecaplab">
      <i class="bi bi-instagram" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
<p>Construído com <a href="https://quarto.org/">Quarto.org</a>.</p>
</div>
  </div>
</footer>




</body></html>